// automatically generated by Xtext
grammar org.kermeta.language.sample.cellularautomata.rules.cs.Rule with org.eclipse.xtext.common.Terminals 

import "platform:/resource/org.kermeta.language.sample.cellularautomata.rules.model/metamodel/rules.ecore" 

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

CellularAutomata returns CellularAutomata:
	rules+=Rule+
;

Rule returns Rule:
	'rule' (filter=PopulationRange)? '=' nextValue=IntegerExpression ';'
;

/*
 * Population range
 */
PopulationRange returns PopulationRange:
	{PopulationRange}
	'['	(lowerRange=EInt)? ',' (upperRange=EInt)? ']';

/*
 * Integer expression (class IntegerExpression should probably be abstract)
 */ 
IntegerExpression_Impl returns IntegerExpression:
	{IntegerExpression}
	'IntegerExpression'
;

IntegerExpression returns IntegerExpression:
	/*IntegerExpression_Impl |*/ Max | Add | /*UnaryExpression_Impl |*/ And | Or | Not | Greater | Lower | IntegerLiteral | Conditional | CurrentCellPopulation | Size | /*NeighborsExpression_Impl |*/ Min | /*BinaryExpression_Impl |*/ Mult | Div | Sum | Mod | UMinus | Minus | Equal;


/*
 * Binary expressions (class BinaryExpression should probably be abstract)
 */
BinaryExpression_Impl returns BinaryExpression:
	'BinaryExpression'
	'{'
		'left' left=IntegerExpression
		'right' right=IntegerExpression
    '}';

Mult returns Mult:
	'*' '(' left=IntegerExpression ',' right=IntegerExpression ')';

Div returns Div:
	'/''(' left=IntegerExpression ',' right=IntegerExpression ')';

Mod returns Mod:
	'%' '(' left=IntegerExpression ',' right=IntegerExpression ')';

Add returns Add:
	'+' '(' left=IntegerExpression ',' right=IntegerExpression ')';
	
Minus returns Minus:
	'-' '(' left=IntegerExpression ',' right=IntegerExpression ')';

And returns And:
	'and' '(' left=IntegerExpression ',' right=IntegerExpression ')';

Or returns Or:
	'or' '(' left=IntegerExpression ',' right=IntegerExpression ')';

Greater returns Greater:
	'>' '(' left=IntegerExpression ',' right=IntegerExpression ')';

Lower returns Lower:
	'<' '(' left=IntegerExpression ',' right=IntegerExpression ')';

Equal returns Equal:
	'eql' '(' left=IntegerExpression ',' right=IntegerExpression ')';

/*
 * Unary expressions (class UnaryExpression should probably be abstract)
 */
UnaryExpression_Impl returns UnaryExpression:
	'UnaryExpression'
	'{'
		'target' target=IntegerExpression
    '}';

Not returns Not:
	'!' '(' target=IntegerExpression ')';

UMinus returns UMinus:
	'--' '('target=IntegerExpression')';

/*
 * Neighbors expressions (class NeighborExpression should probably be abstract)
 */
NeighborsExpression_Impl returns NeighborsExpression:
	{NeighborsExpression}
	'NeighborsExpression'
	'{'
		('neighborsFilter' neighborsFilter=PopulationRange)?
    '}';

Max returns Max:
	{Max}
	'neighborsMax' (neighborsFilter=PopulationRange)?;

Min returns Min:
	{Min}
	'neighborsMin' (neighborsFilter=PopulationRange)?;

Sum returns Sum:
	{Sum}
	'neighborsSum' (neighborsFilter=PopulationRange)?;

Size returns Size:
	{Size}
	'neighborsSize' (neighborsFilter=PopulationRange)?;

/*
 * Conditional
 */
Conditional returns Conditional:
	'if' '('condition=IntegerExpression')' '{'
		ifTrueExpression=IntegerExpression
	'}'
	'else'
	'{'
		ifFalseExpression=IntegerExpression
    '}';


/*
 * Literals and terminals
 */
CurrentCellPopulation returns CurrentCellPopulation:
	{CurrentCellPopulation}
	'CellPopulation'
;

IntegerLiteral returns IntegerLiteral:
	value=EInt;

EInt returns ecore::EInt:
	'-'? INT;
	
/*terminal UnlimitedInt:
	INT | '-inf' | 'inf'
;*/
