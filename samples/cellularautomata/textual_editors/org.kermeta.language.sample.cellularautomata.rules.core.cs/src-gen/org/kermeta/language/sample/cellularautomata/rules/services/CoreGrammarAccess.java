/*
* generated by Xtext
*/

package org.kermeta.language.sample.cellularautomata.rules.services;

import com.google.inject.Singleton;
import com.google.inject.Inject;

import java.util.List;

import org.eclipse.xtext.*;
import org.eclipse.xtext.service.GrammarProvider;
import org.eclipse.xtext.service.AbstractElementFinder.*;

import org.eclipse.xtext.common.services.TerminalsGrammarAccess;

@Singleton
public class CoreGrammarAccess extends AbstractGrammarElementFinder {
	
	
	public class RuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Rule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cWhenKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cValueKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cEqualsSignKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cEvaluatedValAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEvaluatedValConditionalParserRuleCall_3_0 = (RuleCall)cEvaluatedValAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		/// *
		//
		// * Operators precedence (Corresponding rule):
		//
		// * 1	(), neighbors expressions	(NeighborsExpression)
		//
		// * 2	!,-							(UnaryExpression)
		//
		// * 3	*,/,%						(MultExpression)
		//
		// * 4	+,-							(AddExpression)
		//
		// * 5	==							(EqualExpression)
		//
		// * 6	<,>							(ComparisonExpression)
		//
		// * 7	&							(AndExpression)
		//
		// * 8	|							(OrExpression)
		//
		// * 9	if							(Conditional)
		//
		// * / Rule:
		//
		//	"when" / *Filter* / "value" "=" evaluatedVal=Conditional ";";
		public ParserRule getRule() { return rule; }

		//"when" / *Filter* / "value" "=" evaluatedVal=Conditional ";"
		public Group getGroup() { return cGroup; }

		//"when"
		public Keyword getWhenKeyword_0() { return cWhenKeyword_0; }

		/// *Filter* / "value"
		public Keyword getValueKeyword_1() { return cValueKeyword_1; }

		//"="
		public Keyword getEqualsSignKeyword_2() { return cEqualsSignKeyword_2; }

		//evaluatedVal=Conditional
		public Assignment getEvaluatedValAssignment_3() { return cEvaluatedValAssignment_3; }

		//Conditional
		public RuleCall getEvaluatedValConditionalParserRuleCall_3_0() { return cEvaluatedValConditionalParserRuleCall_3_0; }

		//";"
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}

	public class ConditionalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "Conditional");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cOrExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cConditionalAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cIfKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cConditionAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cConditionConditionalParserRuleCall_1_2_0 = (RuleCall)cConditionAssignment_1_2.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1_3 = (Keyword)cGroup_1.eContents().get(3);
		private final Assignment cIfTrueExpressionAssignment_1_4 = (Assignment)cGroup_1.eContents().get(4);
		private final RuleCall cIfTrueExpressionConditionalParserRuleCall_1_4_0 = (RuleCall)cIfTrueExpressionAssignment_1_4.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_5 = (Keyword)cGroup_1.eContents().get(5);
		private final Keyword cElseKeyword_1_6 = (Keyword)cGroup_1.eContents().get(6);
		private final Keyword cLeftCurlyBracketKeyword_1_7 = (Keyword)cGroup_1.eContents().get(7);
		private final Assignment cIfFalseExpressionAssignment_1_8 = (Assignment)cGroup_1.eContents().get(8);
		private final RuleCall cIfFalseExpressionConditionalParserRuleCall_1_8_0 = (RuleCall)cIfFalseExpressionAssignment_1_8.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_9 = (Keyword)cGroup_1.eContents().get(9);
		
		/// *
		//
		// * Conditional
		//
		// * / Conditional returns IntegerExpression:
		//
		//	OrExpression | {Conditional} "if" condition=Conditional "{" ifTrueExpression=Conditional "}" "else" "{"
		//
		//	ifFalseExpression=Conditional "}";
		public ParserRule getRule() { return rule; }

		//OrExpression | {Conditional} "if" condition=Conditional "{" ifTrueExpression=Conditional "}" "else" "{"
		//
		//ifFalseExpression=Conditional "}"
		public Alternatives getAlternatives() { return cAlternatives; }

		//OrExpression
		public RuleCall getOrExpressionParserRuleCall_0() { return cOrExpressionParserRuleCall_0; }

		//{Conditional} "if" condition=Conditional "{" ifTrueExpression=Conditional "}" "else" "{" ifFalseExpression=Conditional
		//
		//"}"
		public Group getGroup_1() { return cGroup_1; }

		//{Conditional}
		public Action getConditionalAction_1_0() { return cConditionalAction_1_0; }

		//"if"
		public Keyword getIfKeyword_1_1() { return cIfKeyword_1_1; }

		//condition=Conditional
		public Assignment getConditionAssignment_1_2() { return cConditionAssignment_1_2; }

		//Conditional
		public RuleCall getConditionConditionalParserRuleCall_1_2_0() { return cConditionConditionalParserRuleCall_1_2_0; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_3() { return cLeftCurlyBracketKeyword_1_3; }

		//ifTrueExpression=Conditional
		public Assignment getIfTrueExpressionAssignment_1_4() { return cIfTrueExpressionAssignment_1_4; }

		//Conditional
		public RuleCall getIfTrueExpressionConditionalParserRuleCall_1_4_0() { return cIfTrueExpressionConditionalParserRuleCall_1_4_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_5() { return cRightCurlyBracketKeyword_1_5; }

		//"else"
		public Keyword getElseKeyword_1_6() { return cElseKeyword_1_6; }

		//"{"
		public Keyword getLeftCurlyBracketKeyword_1_7() { return cLeftCurlyBracketKeyword_1_7; }

		//ifFalseExpression=Conditional
		public Assignment getIfFalseExpressionAssignment_1_8() { return cIfFalseExpressionAssignment_1_8; }

		//Conditional
		public RuleCall getIfFalseExpressionConditionalParserRuleCall_1_8_0() { return cIfFalseExpressionConditionalParserRuleCall_1_8_0; }

		//"}"
		public Keyword getRightCurlyBracketKeyword_1_9() { return cRightCurlyBracketKeyword_1_9; }
	}

	public class OrExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "OrExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAndExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cOrLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightAndExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		/// *
		//
		// * Binary expressions
		//
		// * / OrExpression returns IntegerExpression:
		//
		//	AndExpression ({Or.left=current} "|" right=AndExpression)*;
		public ParserRule getRule() { return rule; }

		//AndExpression ({Or.left=current} "|" right=AndExpression)*
		public Group getGroup() { return cGroup; }

		//AndExpression
		public RuleCall getAndExpressionParserRuleCall_0() { return cAndExpressionParserRuleCall_0; }

		//({Or.left=current} "|" right=AndExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Or.left=current}
		public Action getOrLeftAction_1_0() { return cOrLeftAction_1_0; }

		//"|"
		public Keyword getVerticalLineKeyword_1_1() { return cVerticalLineKeyword_1_1; }

		//right=AndExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//AndExpression
		public RuleCall getRightAndExpressionParserRuleCall_1_2_0() { return cRightAndExpressionParserRuleCall_1_2_0; }
	}

	public class AndExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AndExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEqualExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cAndLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cAmpersandKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightEqualExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//AndExpression returns IntegerExpression:
		//
		//	EqualExpression ({And.left=current} "&" right=EqualExpression)*;
		public ParserRule getRule() { return rule; }

		//EqualExpression ({And.left=current} "&" right=EqualExpression)*
		public Group getGroup() { return cGroup; }

		//EqualExpression
		public RuleCall getEqualExpressionParserRuleCall_0() { return cEqualExpressionParserRuleCall_0; }

		//({And.left=current} "&" right=EqualExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{And.left=current}
		public Action getAndLeftAction_1_0() { return cAndLeftAction_1_0; }

		//"&"
		public Keyword getAmpersandKeyword_1_1() { return cAmpersandKeyword_1_1; }

		//right=EqualExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//EqualExpression
		public RuleCall getRightEqualExpressionParserRuleCall_1_2_0() { return cRightEqualExpressionParserRuleCall_1_2_0; }
	}

	public class EqualExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EqualExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cComparisonExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Action cEqualLeftAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cEqualsSignEqualsSignKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cRightAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cRightComparisonExpressionParserRuleCall_1_2_0 = (RuleCall)cRightAssignment_1_2.eContents().get(0);
		
		//EqualExpression returns IntegerExpression:
		//
		//	ComparisonExpression ({Equal.left=current} "==" right=ComparisonExpression)*;
		public ParserRule getRule() { return rule; }

		//ComparisonExpression ({Equal.left=current} "==" right=ComparisonExpression)*
		public Group getGroup() { return cGroup; }

		//ComparisonExpression
		public RuleCall getComparisonExpressionParserRuleCall_0() { return cComparisonExpressionParserRuleCall_0; }

		//({Equal.left=current} "==" right=ComparisonExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Equal.left=current}
		public Action getEqualLeftAction_1_0() { return cEqualLeftAction_1_0; }

		//"=="
		public Keyword getEqualsSignEqualsSignKeyword_1_1() { return cEqualsSignEqualsSignKeyword_1_1; }

		//right=ComparisonExpression
		public Assignment getRightAssignment_1_2() { return cRightAssignment_1_2; }

		//ComparisonExpression
		public RuleCall getRightComparisonExpressionParserRuleCall_1_2_0() { return cRightComparisonExpressionParserRuleCall_1_2_0; }
	}

	public class ComparisonExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "ComparisonExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cAddExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cGreaterLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cGreaterThanSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cLowerLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cLessThanSignKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightAddExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//ComparisonExpression returns IntegerExpression:
		//
		//	AddExpression (({Greater.left=current} ">" | {Lower.left=current} "<") right=AddExpression)*;
		public ParserRule getRule() { return rule; }

		//AddExpression (({Greater.left=current} ">" | {Lower.left=current} "<") right=AddExpression)*
		public Group getGroup() { return cGroup; }

		//AddExpression
		public RuleCall getAddExpressionParserRuleCall_0() { return cAddExpressionParserRuleCall_0; }

		//(({Greater.left=current} ">" | {Lower.left=current} "<") right=AddExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Greater.left=current} ">" | {Lower.left=current} "<"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Greater.left=current} ">"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Greater.left=current}
		public Action getGreaterLeftAction_1_0_0_0() { return cGreaterLeftAction_1_0_0_0; }

		//">"
		public Keyword getGreaterThanSignKeyword_1_0_0_1() { return cGreaterThanSignKeyword_1_0_0_1; }

		//{Lower.left=current} "<"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Lower.left=current}
		public Action getLowerLeftAction_1_0_1_0() { return cLowerLeftAction_1_0_1_0; }

		//"<"
		public Keyword getLessThanSignKeyword_1_0_1_1() { return cLessThanSignKeyword_1_0_1_1; }

		//right=AddExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//AddExpression
		public RuleCall getRightAddExpressionParserRuleCall_1_1_0() { return cRightAddExpressionParserRuleCall_1_1_0; }
	}

	public class AddExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "AddExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cMultExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cAddLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cPlusSignKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cMinusLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightMultExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//AddExpression returns IntegerExpression:
		//
		//	MultExpression (({Add.left=current} "+" | {Minus.left=current} "-") right=MultExpression)*;
		public ParserRule getRule() { return rule; }

		//MultExpression (({Add.left=current} "+" | {Minus.left=current} "-") right=MultExpression)*
		public Group getGroup() { return cGroup; }

		//MultExpression
		public RuleCall getMultExpressionParserRuleCall_0() { return cMultExpressionParserRuleCall_0; }

		//(({Add.left=current} "+" | {Minus.left=current} "-") right=MultExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Add.left=current} "+" | {Minus.left=current} "-"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Add.left=current} "+"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Add.left=current}
		public Action getAddLeftAction_1_0_0_0() { return cAddLeftAction_1_0_0_0; }

		//"+"
		public Keyword getPlusSignKeyword_1_0_0_1() { return cPlusSignKeyword_1_0_0_1; }

		//{Minus.left=current} "-"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Minus.left=current}
		public Action getMinusLeftAction_1_0_1_0() { return cMinusLeftAction_1_0_1_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_1_0_1_1() { return cHyphenMinusKeyword_1_0_1_1; }

		//right=MultExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//MultExpression
		public RuleCall getRightMultExpressionParserRuleCall_1_1_0() { return cRightMultExpressionParserRuleCall_1_1_0; }
	}

	public class MultExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "MultExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cUnaryExpressionParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_1_0 = (Alternatives)cGroup_1.eContents().get(0);
		private final Group cGroup_1_0_0 = (Group)cAlternatives_1_0.eContents().get(0);
		private final Action cMultLeftAction_1_0_0_0 = (Action)cGroup_1_0_0.eContents().get(0);
		private final Keyword cAsteriskKeyword_1_0_0_1 = (Keyword)cGroup_1_0_0.eContents().get(1);
		private final Group cGroup_1_0_1 = (Group)cAlternatives_1_0.eContents().get(1);
		private final Action cDivLeftAction_1_0_1_0 = (Action)cGroup_1_0_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_0_1_1 = (Keyword)cGroup_1_0_1.eContents().get(1);
		private final Group cGroup_1_0_2 = (Group)cAlternatives_1_0.eContents().get(2);
		private final Action cModLeftAction_1_0_2_0 = (Action)cGroup_1_0_2.eContents().get(0);
		private final Keyword cPercentSignKeyword_1_0_2_1 = (Keyword)cGroup_1_0_2.eContents().get(1);
		private final Assignment cRightAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cRightUnaryExpressionParserRuleCall_1_1_0 = (RuleCall)cRightAssignment_1_1.eContents().get(0);
		
		//MultExpression returns IntegerExpression:
		//
		//	UnaryExpression (({Mult.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=UnaryExpression)*;
		public ParserRule getRule() { return rule; }

		//UnaryExpression (({Mult.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=UnaryExpression)*
		public Group getGroup() { return cGroup; }

		//UnaryExpression
		public RuleCall getUnaryExpressionParserRuleCall_0() { return cUnaryExpressionParserRuleCall_0; }

		//(({Mult.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=UnaryExpression)*
		public Group getGroup_1() { return cGroup_1; }

		//{Mult.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%"
		public Alternatives getAlternatives_1_0() { return cAlternatives_1_0; }

		//{Mult.left=current} "*"
		public Group getGroup_1_0_0() { return cGroup_1_0_0; }

		//{Mult.left=current}
		public Action getMultLeftAction_1_0_0_0() { return cMultLeftAction_1_0_0_0; }

		//"*"
		public Keyword getAsteriskKeyword_1_0_0_1() { return cAsteriskKeyword_1_0_0_1; }

		//{Div.left=current} "/"
		public Group getGroup_1_0_1() { return cGroup_1_0_1; }

		//{Div.left=current}
		public Action getDivLeftAction_1_0_1_0() { return cDivLeftAction_1_0_1_0; }

		//"/"
		public Keyword getSolidusKeyword_1_0_1_1() { return cSolidusKeyword_1_0_1_1; }

		//{Mod.left=current} "%"
		public Group getGroup_1_0_2() { return cGroup_1_0_2; }

		//{Mod.left=current}
		public Action getModLeftAction_1_0_2_0() { return cModLeftAction_1_0_2_0; }

		//"%"
		public Keyword getPercentSignKeyword_1_0_2_1() { return cPercentSignKeyword_1_0_2_1; }

		//right=UnaryExpression
		public Assignment getRightAssignment_1_1() { return cRightAssignment_1_1; }

		//UnaryExpression
		public RuleCall getRightUnaryExpressionParserRuleCall_1_1_0() { return cRightUnaryExpressionParserRuleCall_1_1_0; }
	}

	public class UnaryExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "UnaryExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cLiteralsExpressionParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Action cNotAction_1_0 = (Action)cGroup_1.eContents().get(0);
		private final Keyword cExclamationMarkKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cTargetAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cTargetLiteralsExpressionParserRuleCall_1_2_0 = (RuleCall)cTargetAssignment_1_2.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Action cUMinusAction_2_0 = (Action)cGroup_2.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_2_1 = (Keyword)cGroup_2.eContents().get(1);
		private final Assignment cTargetAssignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cTargetLiteralsExpressionParserRuleCall_2_2_0 = (RuleCall)cTargetAssignment_2_2.eContents().get(0);
		
		/// *
		//
		// * Unary expressions
		//
		// * / UnaryExpression returns IntegerExpression:
		//
		//	LiteralsExpression | {Not} "!" target=LiteralsExpression | {UMinus} "-" target=LiteralsExpression;
		public ParserRule getRule() { return rule; }

		//LiteralsExpression | {Not} "!" target=LiteralsExpression | {UMinus} "-" target=LiteralsExpression
		public Alternatives getAlternatives() { return cAlternatives; }

		//LiteralsExpression
		public RuleCall getLiteralsExpressionParserRuleCall_0() { return cLiteralsExpressionParserRuleCall_0; }

		//{Not} "!" target=LiteralsExpression
		public Group getGroup_1() { return cGroup_1; }

		//{Not}
		public Action getNotAction_1_0() { return cNotAction_1_0; }

		//"!"
		public Keyword getExclamationMarkKeyword_1_1() { return cExclamationMarkKeyword_1_1; }

		//target=LiteralsExpression
		public Assignment getTargetAssignment_1_2() { return cTargetAssignment_1_2; }

		//LiteralsExpression
		public RuleCall getTargetLiteralsExpressionParserRuleCall_1_2_0() { return cTargetLiteralsExpressionParserRuleCall_1_2_0; }

		//{UMinus} "-" target=LiteralsExpression
		public Group getGroup_2() { return cGroup_2; }

		//{UMinus}
		public Action getUMinusAction_2_0() { return cUMinusAction_2_0; }

		//"-"
		public Keyword getHyphenMinusKeyword_2_1() { return cHyphenMinusKeyword_2_1; }

		//target=LiteralsExpression
		public Assignment getTargetAssignment_2_2() { return cTargetAssignment_2_2; }

		//LiteralsExpression
		public RuleCall getTargetLiteralsExpressionParserRuleCall_2_2_0() { return cTargetLiteralsExpressionParserRuleCall_2_2_0; }
	}

	public class LiteralsExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "LiteralsExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Keyword cLeftParenthesisKeyword_0_0 = (Keyword)cGroup_0.eContents().get(0);
		private final RuleCall cConditionalParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Keyword cRightParenthesisKeyword_0_2 = (Keyword)cGroup_0.eContents().get(2);
		private final RuleCall cIntegerLiteralParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//LiteralsExpression returns IntegerExpression:
		//
		//	"(" Conditional ")" | / *Max | Min | Sum | Size | CurrentCellPopulation |* / IntegerLiteral;
		public ParserRule getRule() { return rule; }

		//"(" Conditional ")" | / *Max | Min | Sum | Size | CurrentCellPopulation |* / IntegerLiteral
		public Alternatives getAlternatives() { return cAlternatives; }

		//"(" Conditional ")"
		public Group getGroup_0() { return cGroup_0; }

		//"("
		public Keyword getLeftParenthesisKeyword_0_0() { return cLeftParenthesisKeyword_0_0; }

		//Conditional
		public RuleCall getConditionalParserRuleCall_0_1() { return cConditionalParserRuleCall_0_1; }

		//")"
		public Keyword getRightParenthesisKeyword_0_2() { return cRightParenthesisKeyword_0_2; }

		/// *Max | Min | Sum | Size | CurrentCellPopulation |* / IntegerLiteral
		public RuleCall getIntegerLiteralParserRuleCall_1() { return cIntegerLiteralParserRuleCall_1; }
	}

	public class IntegerLiteralElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "IntegerLiteral");
		private final Assignment cValAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cValEIntParserRuleCall_0 = (RuleCall)cValAssignment.eContents().get(0);
		
		//IntegerLiteral:
		//
		//	val=EInt;
		public ParserRule getRule() { return rule; }

		//val=EInt
		public Assignment getValAssignment() { return cValAssignment; }

		//EInt
		public RuleCall getValEIntParserRuleCall_0() { return cValEIntParserRuleCall_0; }
	}

	public class EIntElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "EInt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cHyphenMinusKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cINTTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		
		//EInt returns ecore::EInt:
		//
		//	"-"? INT;
		public ParserRule getRule() { return rule; }

		//"-"? INT
		public Group getGroup() { return cGroup; }

		//"-"?
		public Keyword getHyphenMinusKeyword_0() { return cHyphenMinusKeyword_0; }

		//INT
		public RuleCall getINTTerminalRuleCall_1() { return cINTTerminalRuleCall_1; }
	}
	
	
	private RuleElements pRule;
	private ConditionalElements pConditional;
	private OrExpressionElements pOrExpression;
	private AndExpressionElements pAndExpression;
	private EqualExpressionElements pEqualExpression;
	private ComparisonExpressionElements pComparisonExpression;
	private AddExpressionElements pAddExpression;
	private MultExpressionElements pMultExpression;
	private UnaryExpressionElements pUnaryExpression;
	private LiteralsExpressionElements pLiteralsExpression;
	private IntegerLiteralElements pIntegerLiteral;
	private EIntElements pEInt;
	
	private final Grammar grammar;

	private TerminalsGrammarAccess gaTerminals;

	@Inject
	public CoreGrammarAccess(GrammarProvider grammarProvider,
		TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.kermeta.language.sample.cellularautomata.rules.Core".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	
	public Grammar getGrammar() {
		return grammar;
	}
	

	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	/// *
	//
	// * Operators precedence (Corresponding rule):
	//
	// * 1	(), neighbors expressions	(NeighborsExpression)
	//
	// * 2	!,-							(UnaryExpression)
	//
	// * 3	*,/,%						(MultExpression)
	//
	// * 4	+,-							(AddExpression)
	//
	// * 5	==							(EqualExpression)
	//
	// * 6	<,>							(ComparisonExpression)
	//
	// * 7	&							(AndExpression)
	//
	// * 8	|							(OrExpression)
	//
	// * 9	if							(Conditional)
	//
	// * / Rule:
	//
	//	"when" / *Filter* / "value" "=" evaluatedVal=Conditional ";";
	public RuleElements getRuleAccess() {
		return (pRule != null) ? pRule : (pRule = new RuleElements());
	}
	
	public ParserRule getRuleRule() {
		return getRuleAccess().getRule();
	}

	/// *
	//
	// * Conditional
	//
	// * / Conditional returns IntegerExpression:
	//
	//	OrExpression | {Conditional} "if" condition=Conditional "{" ifTrueExpression=Conditional "}" "else" "{"
	//
	//	ifFalseExpression=Conditional "}";
	public ConditionalElements getConditionalAccess() {
		return (pConditional != null) ? pConditional : (pConditional = new ConditionalElements());
	}
	
	public ParserRule getConditionalRule() {
		return getConditionalAccess().getRule();
	}

	/// *
	//
	// * Binary expressions
	//
	// * / OrExpression returns IntegerExpression:
	//
	//	AndExpression ({Or.left=current} "|" right=AndExpression)*;
	public OrExpressionElements getOrExpressionAccess() {
		return (pOrExpression != null) ? pOrExpression : (pOrExpression = new OrExpressionElements());
	}
	
	public ParserRule getOrExpressionRule() {
		return getOrExpressionAccess().getRule();
	}

	//AndExpression returns IntegerExpression:
	//
	//	EqualExpression ({And.left=current} "&" right=EqualExpression)*;
	public AndExpressionElements getAndExpressionAccess() {
		return (pAndExpression != null) ? pAndExpression : (pAndExpression = new AndExpressionElements());
	}
	
	public ParserRule getAndExpressionRule() {
		return getAndExpressionAccess().getRule();
	}

	//EqualExpression returns IntegerExpression:
	//
	//	ComparisonExpression ({Equal.left=current} "==" right=ComparisonExpression)*;
	public EqualExpressionElements getEqualExpressionAccess() {
		return (pEqualExpression != null) ? pEqualExpression : (pEqualExpression = new EqualExpressionElements());
	}
	
	public ParserRule getEqualExpressionRule() {
		return getEqualExpressionAccess().getRule();
	}

	//ComparisonExpression returns IntegerExpression:
	//
	//	AddExpression (({Greater.left=current} ">" | {Lower.left=current} "<") right=AddExpression)*;
	public ComparisonExpressionElements getComparisonExpressionAccess() {
		return (pComparisonExpression != null) ? pComparisonExpression : (pComparisonExpression = new ComparisonExpressionElements());
	}
	
	public ParserRule getComparisonExpressionRule() {
		return getComparisonExpressionAccess().getRule();
	}

	//AddExpression returns IntegerExpression:
	//
	//	MultExpression (({Add.left=current} "+" | {Minus.left=current} "-") right=MultExpression)*;
	public AddExpressionElements getAddExpressionAccess() {
		return (pAddExpression != null) ? pAddExpression : (pAddExpression = new AddExpressionElements());
	}
	
	public ParserRule getAddExpressionRule() {
		return getAddExpressionAccess().getRule();
	}

	//MultExpression returns IntegerExpression:
	//
	//	UnaryExpression (({Mult.left=current} "*" | {Div.left=current} "/" | {Mod.left=current} "%") right=UnaryExpression)*;
	public MultExpressionElements getMultExpressionAccess() {
		return (pMultExpression != null) ? pMultExpression : (pMultExpression = new MultExpressionElements());
	}
	
	public ParserRule getMultExpressionRule() {
		return getMultExpressionAccess().getRule();
	}

	/// *
	//
	// * Unary expressions
	//
	// * / UnaryExpression returns IntegerExpression:
	//
	//	LiteralsExpression | {Not} "!" target=LiteralsExpression | {UMinus} "-" target=LiteralsExpression;
	public UnaryExpressionElements getUnaryExpressionAccess() {
		return (pUnaryExpression != null) ? pUnaryExpression : (pUnaryExpression = new UnaryExpressionElements());
	}
	
	public ParserRule getUnaryExpressionRule() {
		return getUnaryExpressionAccess().getRule();
	}

	//LiteralsExpression returns IntegerExpression:
	//
	//	"(" Conditional ")" | / *Max | Min | Sum | Size | CurrentCellPopulation |* / IntegerLiteral;
	public LiteralsExpressionElements getLiteralsExpressionAccess() {
		return (pLiteralsExpression != null) ? pLiteralsExpression : (pLiteralsExpression = new LiteralsExpressionElements());
	}
	
	public ParserRule getLiteralsExpressionRule() {
		return getLiteralsExpressionAccess().getRule();
	}

	//IntegerLiteral:
	//
	//	val=EInt;
	public IntegerLiteralElements getIntegerLiteralAccess() {
		return (pIntegerLiteral != null) ? pIntegerLiteral : (pIntegerLiteral = new IntegerLiteralElements());
	}
	
	public ParserRule getIntegerLiteralRule() {
		return getIntegerLiteralAccess().getRule();
	}

	//EInt returns ecore::EInt:
	//
	//	"-"? INT;
	public EIntElements getEIntAccess() {
		return (pEInt != null) ? pEInt : (pEInt = new EIntElements());
	}
	
	public ParserRule getEIntRule() {
		return getEIntAccess().getRule();
	}

	//terminal ID:
	//
	//	"^"? ("a".."z" | "A".."Z" | "_") ("a".."z" | "A".."Z" | "_" | "0".."9")*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	} 

	//terminal INT returns ecore::EInt:
	//
	//	"0".."9"+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	} 

	//terminal STRING:
	//
	//	"\"" ("\\" ("b" | "t" | "n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\""))* "\"" | "\'" ("\\" ("b" | "t" |
	//
	//	"n" | "f" | "r" | "u" | "\"" | "\'" | "\\") | !("\\" | "\'"))* "\'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	} 

	//terminal ML_COMMENT:
	//
	//	"/ *"->"* /";
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	} 

	//terminal SL_COMMENT:
	//
	//	"//" !("\n" | "\r")* ("\r"? "\n")?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	} 

	//terminal WS:
	//
	//	(" " | "\t" | "\r" | "\n")+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	} 

	//terminal ANY_OTHER:
	//
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	} 
}
